#!/bin/bash
# digitize-cd
#===================================================================================
#
#         FILE: digitize-cd
#
#        USAGE: digitize-cd
#
#      SUMMARY: Script to digitize my CD collection and manage the resulting files.
#  DESCRIPTION: This is a lot of glue and automation on top of my other actual 
#               ripping and transcoding functions.  It's been kind of fun designing
#               and figuring out how to do this.
#
#      PROJECT: Media Collection (media-archive)
#      OPTIONS: 
# REQUIREMENTS: asdf
# PACKAGES REQ: asdf
#         BUGS: Probably dozens.
#        NOTES: ---
#       AUTHOR: KlfJoat
#      VERSION: 0.1
#      CREATED: 2014-05-03
#     REVISION: ---
#===================================================================================
# Debug
set -x
################################
####### CHECK CONDITIONS #######
################################
### Check for necessary commands
my_needed_commands="mktemp zenity"
missing_counter=0
for needed_command in $my_needed_commands; do
  if ! hash "$needed_command" >/dev/null 2>&1; then
    printf "Command not found in PATH: %s\n" "$needed_command" >&2
    ((missing_counter++))
  fi
done
if ((missing_counter > 0)); then
  printf "Minimum %d commands are missing in PATH, aborting\n" "$missing_counter" >&2
  exit 1
fi

### TODO: Check for enough HDD space.  ??43GB = 18GB + 25GB buffer

##############################
####### INITIALIZATION #######
##############################
### Variables
workingdir="$HOME/tmp"
nas_rip="$HOME/Audio/Rips"
nas_transcode="$HOME/Audio/Music/MyCDs"
holding_rip="$HOME/tmp/MoveToRipDrive"
holding_transcode="$HOME/tmp/MoveToTranscodeDrive"
dir_rip="CD-Rip"
dir_transcode="CD-Transcode"

### Ensure directories are created for the working, NAS, and holding variables.
mkdir --parents "$workingdir"
mkdir --parents "$nas_rip"
mkdir --parents "$nas_transcode"
mkdir --parents "$holding_rip"
mkdir --parents "$holding_transcode"
      
### Create temp dir
TMPDIR=$(mktemp --quiet --directory --tmpdir="$workingdir" cd.XXXXXX) || { echo "Failed to create temp directory."; exit 1; }
olddir=$(pwd)
cd "$TMPDIR"

### Set up traps for program exit

###########################################
####### DUAL - RIP AND GET CD INFO #######
###########################################
$HOME/src/media-archive/cdto1flac

### Figure out FLAC filename (should be the only one in our temp directory)
flacfile=$(find *.flac)

# Delete extraneous cuesheet
/bin/rm "$flacfile.cue"


###########################################
#?????? ADD DISC TO TOC SPREADSHEET ???????
###########################################

#########################
####### TRANSCODE #######
#########################
$HOME/src/media-archive/1flactoogg "$flacfile"

### Get directory of filename minus dirs and minus ext (use for transcode filename)
transcodedir=$(find * -maxdepth 0 -type d)

###########################
####### COPY TO NAS #######
###########################
### Check for filename collision
# Rip collision
if [[ -f "$nas_rip/$flacfile" ]]; then
  echo "$nas_rip/$flacfile already exists!  Exiting." >&2
  zenity --error --text="$nas_rip/$flacfile already exists!  Exiting."
  exit 1
fi
# Transcode collision - the copy below will complain if that's the case.

### Copy rip to NAS
cp --verbose --recursive --no-clobber "$flacfile" "$nas_rip"
### Copy transcode to NAS
cp --verbose --recursive --no-clobber "$transcodedir" "$nas_transcode"

###############################################
####### COPY TO EXT HDD OR HOLDING AREA #######
###############################################
# Variables - RegExps to use.
ripregexp="\/Rip"
transcoderegexp="\/Transcode"

### First, make sure only one of each recognizable drive is attached.
### Then, set the drives' mount points. 
# Find 1 Rip drive
ripcount=$(grep --count "$ripregexp" /proc/mounts)
if [[ $ripcount -eq 1 ]];
  # The perl regex replaces 5 groups of non-spaces+spaces with nothing, 
  # leaving only the rest of line. Which is the mount point including any 
  # possible spaces.  "|awk '{print $6}'" would work, except for spaces.
  $ripdrive=$(df -P | grep $ripregexp | perl -pe 's/^(\S+\s+){5}//')
fi

# Find 1 Transcode drive
transcodecount=$(grep --count "$transcoderegexp" /proc/mounts)
if [[ $transcodecount -eq 1 ]];
  # The perl regex replaces 5 groups of non-spaces+spaces with nothing, 
  # leaving only the rest of line. Which is the mount point including any 
  # possible spaces.  "|awk '{print $6}'" would work, except for spaces.
  $transcodedrive=$(df -P | grep $transcoderegexp | perl -pe 's/^(\S+\s+){5}//')
fi

### ??Check for filename collision??

### Copy rip to ext HDD, if mounted; holding dir if not.
if [[ "$ripdrive" ]]; then
  mkdir --parents "$ripdrive"/"$dir_rip"
  cp --verbose --recursive --no-clobber "$flacfile" "$ripdrive"/"$dir_rip"
else
  # Make holding directory if it doesn't exist
  cp --verbose --recursive --no-clobber "$flacfile" "$holding_rip"
fi

### Copy transcode to ext HDD, if mounted; holding dir if not.
if [[ "$transcodedrive" ]]; then
  mkdir --parents "$transcodedrive"/"$dir_transcode"
  cp --verbose --recursive --no-clobber "$transcodedir" "$transcodedrive"/"$dir_transcode"
else
  # Make holding directory if it doesn't exist
  cp --verbose --recursive --no-clobber "$transcodedir" "$holding_transcode"
fi

########################
####### CLEAN UP #######
########################
### Change back
cd "$olddir"

### Delete rip & transcode
/bin/rm -rf "$TMPDIR"
