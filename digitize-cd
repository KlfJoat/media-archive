#!/bin/bash
#===================================================================================
#
#         FILE: digitize-cd
#
#        USAGE: digitize-cd
#
#      SUMMARY: Script to digitize my CD collection and manage the resulting files.
#  DESCRIPTION: This is a lot of glue and automation on top of my other actual 
#               ripping and transcoding functions.  It's been kind of fun designing
#               and figuring out how to do this.
#
#      PROJECT: Media Collection (media-archive)
#      OPTIONS: 
# REQUIREMENTS: cdto1flac, 1flactoogg, mktemp, zenity
# PACKAGES REQ: abcde
#         BUGS: Doesn't do enough checking to ensure commands complete successfully,
#               and then act appropriately.
#        NOTES: TODO: Add support for specifying the CD drive on the command-line.
#       AUTHOR: KlfJoat
#      VERSION: 0.2
#      CREATED: 2014-05-03 to 2014-05-10
#     REVISION: ---
#===================================================================================
# Debug
set -x
################################
####### CHECK CONDITIONS #######
################################
### Check for necessary commands
my_needed_commands="mktemp zenity" # + cdto1flac and 1flactoogg
missing_counter=0
for needed_command in $my_needed_commands; do
  if ! hash "$needed_command" >/dev/null 2>&1; then
    printf "Command not found in PATH: %s\n" "$needed_command" >&2
    ((missing_counter++))
  fi
done
if ((missing_counter > 0)); then
  printf "Minimum %d commands are missing in PATH, aborting\n" "$missing_counter" >&2
  exit 1
fi

### TODO: Check for enough HDD space.  ??43GB = 18GB + 25GB buffer

##############################
####### INITIALIZATION #######
##############################
### Variables
workingdir="$HOME/tmp"
nas_rip="$HOME/Audio/Rips"
nas_transcode="$HOME/Audio/Music/MyCDs"
holding_rip="$HOME/tmp/MoveToRipDrive"
holding_transcode="$HOME/tmp/MoveToTranscodeDrive"
dir_rip="CD-Rip"
dir_transcode="CD-Transcode"

### Ensure directories are created for the working and NAS variables.
mkdir --parents "$workingdir"
mkdir --parents "$nas_rip"
mkdir --parents "$nas_transcode"
      
### Create temp dir
TMPDIR=$(mktemp --quiet --directory --tmpdir="$workingdir" cd.XXXXXX) || { echo "Failed to create temp directory."; exit 1; }
olddir=$(pwd)
cd "$TMPDIR"

### Set up traps for program exit
function clean_up {
  # Perform program exit housekeeping
  cd "$olddir"	# Change back
  /bin/rm -rf "$TMPDIR"   # Delete rip, transcode, and interim files
    trap 0  # reset to default action
  exit
}

trap clean_up 0 1 2 3 15

###########################################
####### DUAL - RIP AND GET CD INFO #######
###########################################
$HOME/src/media-archive/cdto1flac

### Figure out FLAC filename (should be the only one in our temp directory)
flacfile=$(find *.flac)

# Delete extraneous cuesheet
/bin/rm "$flacfile.cue"


###########################################
#?????? ADD DISC TO TOC SPREADSHEET ???????
###########################################

#########################
####### TRANSCODE #######
#########################
$HOME/src/media-archive/1flactoogg "$flacfile"

### Get directory of filename minus dirs and minus ext (use for transcode filename)
transcodedir=$(find * -maxdepth 0 -type d)

###########################
####### COPY TO NAS #######
###########################
### Check for filename collision
# Rip collision
if [[ -f "$nas_rip/$flacfile" ]]; then
  echo "$nas_rip/$flacfile already exists!  Exiting." >&2
  zenity --error --text="$nas_rip/$flacfile already exists!  Exiting."
  exit 1
fi
# Transcode collision - the copy below will complain if that's the case.

### Copy rip to NAS
cp --verbose --recursive --no-clobber "$flacfile" "$nas_rip"
### Copy transcode to NAS
cp --verbose --recursive --no-clobber "$transcodedir" "$nas_transcode"

###############################################
####### COPY TO EXT HDD OR HOLDING AREA #######
###############################################
# Variables - RegExps to use.
ripregexp="\/Rip"
transcoderegexp="\/Transcode"

### First, make sure only one of each recognizable drive is attached.
### Then, set the drives' mount points. 
# Find 1 Rip drive
ripcount=$(grep --count "$ripregexp" /proc/mounts)
if [[ $ripcount -eq 1 ]]; then
  # The perl regex replaces 5 groups of non-spaces+spaces with nothing, 
  # leaving only the rest of line. Which is the mount point including any 
  # possible spaces.  "|awk '{print $6}'" would work, except for spaces.
  ripdrive=$(df -P | grep $ripregexp | perl -pe 's/^(\S+\s+){5}//')
fi

# Find 1 Transcode drive
transcodecount=$(grep --count "$transcoderegexp" /proc/mounts)
if [[ $transcodecount -eq 1 ]]; then
  # The perl regex replaces 5 groups of non-spaces+spaces with nothing, 
  # leaving only the rest of line. Which is the mount point including any 
  # possible spaces.  "|awk '{print $6}'" would work, except for spaces.
  transcodedrive=$(df -P | grep $transcoderegexp | perl -pe 's/^(\S+\s+){5}//')
fi

### ??Check for filename collision??

### Copy rip to ext HDD, if mounted; holding dir if not.
if [[ "$ripdrive" ]]; then
  mkdir --parents "$ripdrive"/"$dir_rip"
  cp --verbose --recursive --no-clobber "$flacfile" "$ripdrive"/"$dir_rip"
else
  mkdir --parents "$holding_rip"/"$dir_rip"
  cp --verbose --recursive --no-clobber "$flacfile" "$holding_rip"/"$dir_rip"
fi

### Copy transcode to ext HDD, if mounted; holding dir if not.
if [[ "$transcodedrive" ]]; then
  mkdir --parents "$transcodedrive"/"$dir_transcode"
  cp --verbose --recursive --no-clobber "$transcodedir" "$transcodedrive"/"$dir_transcode"
else
  mkdir --parents "$holding_transcode"/"$dir_transcode"
  cp --verbose --recursive --no-clobber "$transcodedir" "$holding_transcode"/"$dir_transcode"
fi

########################
####### CLEAN UP #######
########################
### Because of "trap 0", the function clean_up runs here.
